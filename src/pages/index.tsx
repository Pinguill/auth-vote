import { ConnectButton } from '@rainbow-me/rainbowkit';
import type { NextPage } from 'next';
import Head from 'next/head';
import styles from '../styles/Home.module.css';
import { useEffect, useState } from 'react';
import { useSignMessage, useWriteContract, useReadContract, useWaitForTransactionReceipt } from 'wagmi';
import { signMessage , signTypedData } from '@wagmi/core'
import  constants from '../../abi.json'
import { config } from '../wagmi';
import { AbiCoder } from 'ethers';

const Home: NextPage = () => {
  const [vote, setVote] = useState<boolean | null>(null);
  const [signature, setSignature] = useState<string | null>(null);
  const [hashTrx, setHashTrx] = useState<string | null>(null);
  const [yesVotes, setYesVotes] = useState<string | null>(null);
  const [noVotes, setNoVotes] = useState<string | null>(null);
  const { writeContractAsync } = useWriteContract();

  const resultReadYes = useReadContract({
    abi: constants.abi,
    address: constants.address as `0x${string}`,
    functionName: 'getYesVotes'
  });

  const resultReadNo = useReadContract({
    abi: constants.abi,
    address: constants.address as `0x${string}`,
    functionName: 'getNoVotes'
  });


  useEffect( () => {
    setNoVotes(String(resultReadNo.data))
    setYesVotes(String(resultReadYes.data))
  }, [resultReadNo, resultReadYes]);

  // Hook para firmar mensajes con wagmi
  const { signMessageAsync } = useSignMessage();

  const handleVote = async (userVote: boolean) => {
    setVote(userVote);

    // Crear el mensaje JSON
    const message = JSON.stringify({ vote: userVote ? 'yes' : 'no' });

    // Firmar el mensaje
    try {
      const signature = await signMessageAsync({message})
      console.log('El usuario firmo: ' + signature as `x0${string}`)
      setSignature(signature  as `x0${string}`);
    } catch (error) {
      console.error('Error al firmar el mensaje:', error);
    }
  };

  // Llamar a la funci√≥n del contrato despu√©s de que la firma sea exitosa
  const submitVote = async () => {
    if (signature && vote !== null) {
      try {
        const hashTrs = await writeContractAsync({ 
          abi: constants.abi,
          address: constants.address as `0x${string}`,
          functionName: 'vote',
          args: [
            vote,
            signature
          ],
       })
        console.log('Voto enviado con √©xito: ' + hashTrs);
        setHashTrx(hashTrs)
      } catch (error) {
        console.error('Error al enviar el voto:', error);
      }
    }
  };
  

  const resultBlocks = useWaitForTransactionReceipt({
    hash: hashTrx as `0x${string}`,
    confirmations: 2,
    
  });

  useEffect( () => {
    console.log(resultBlocks);
    resultReadNo.refetch();
    resultReadYes.refetch();
  }, [resultBlocks]);
  
  return (
    <div className={styles.container}>
      <Head>
        <title>RainbowKit App</title>
        <meta
          content="Generated by @rainbow-me/create-rainbowkit"
          name="description"
        />
        <link href="/favicon.ico" rel="icon" />
      </Head>

      <main className={styles.main}>
        <ConnectButton />
        <h1>Votaci√≥n en Blockchain</h1>
        <div>
          <b>SI: {yesVotes}</b>
          <b>NO: {noVotes}</b>
        </div>
        <button onClick={() => handleVote(true)}>Votar S√≠</button>
        <button onClick={() => handleVote(false)}>Votar No</button>
        <button onClick={submitVote} disabled={!signature}>
          Enviar Voto
        </button>
      </main>

      <footer className={styles.footer}>
        <a href="https://rainbow.me" rel="noopener noreferrer" target="_blank">
          Made with ‚ù§Ô∏è by your frens at üåà
        </a>
      </footer>
    </div>
  );
};

export default Home;

